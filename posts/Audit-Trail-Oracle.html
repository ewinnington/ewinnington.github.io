
<!DOCTYPE html>
<!--
	Phantom by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en">

	<head>
		<title>Eric Winnington - Using an audit trail table on Oracle</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1" />		
        <link href="/assets/css/highlight.css" rel="stylesheet">
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
        <link href="/assets/css/override.css" rel="stylesheet" />

		<meta name="description" content="A collection of thoughts, code and snippets." />
		<link type="application/rss+xml" rel="alternate" title="Eric Winnington" href="/feed.rss" />
				<link type="application/atom+xml" rel="alternate" title="Eric Winnington" href="/feed.atom" />
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<link rel="icon" href="/favicon.ico" type="image/x-icon">

		<meta name="application-name" content="Eric Winnington" />
		<meta name="msapplication-tooltip" content="Eric Winnington" />
		<meta name="msapplication-starturl" content="/" />

		<meta property="og:title" content="Eric Winnington - Using an audit trail table on Oracle" /> 
		<meta property="og:type" content="website" />
		<meta property="og:url" content="http://ewinnington.github.io/posts/Audit-Trail-Oracle" />
		<!-- TODO: More social graph meta tags -->

        <script src="/assets/js/highlight.pack.js"></script>   
		
        <meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@ewinnington" />
<meta name="twitter:title" content="Eric Winnington - Using an audit trail table on Oracle" />
<meta name="twitter:description" content="A collection of thoughts, code and snippets." />

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
		
	</head>

	<body>
		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
			<header id="header">
				<div class="inner">

					<!-- Logo -->
					<a href="/" class="logo">
						<span class="title">Eric Winnington</span>
					</a>

					<!-- Nav -->
					<nav>
						<ul>
							<li><a href="#menu">Menu</a></li>
						</ul>
					</nav>

				</div>
			</header>

			<!-- Menu -->
			<nav id="menu">
				<h2>Menu</h2>
				<ul>
					        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/about">About Me</a></li>
        <li><a href="/videos">Videos on programming</a></li>

				</ul>
			</nav>

			<!-- Main -->
			<div id="main">
				<div class="inner">

    
<header>
    <h1>Using an audit trail table on Oracle</h1>
            <p><em>Published on Saturday, 5 October 2024</em></p>
            <ul class="actions small">
                    <li><a role="button" href="/tags/CSharp" class="button small">CSharp</a></li>
                    <li><a role="button" href="/tags/Database" class="button small">Database</a></li>
                    <li><a role="button" href="/tags/Oracle" class="button small">Oracle</a></li>
        </ul>     
</header>

					
					<div id="content">
						

<h1 id="implementing-auditable-updates-in-a-relational-database">Implementing Auditable Updates in a Relational Database</h1>
<p>In modern applications, maintaining an audit trail of changes to data is crucial for compliance, debugging, and data integrity. This blog post explores a straightforward approach to implementing auditable updates in a relational database system, specifically focusing on a project management scenario with hierarchical data.</p>
<h2 id="problem-description">Problem Description</h2>
<p>We have a relational database containing <code>Projects</code>, each of which includes <code>Instruments</code>, <code>Markets</code>, and <code>Valuations</code>. These entities form a tree structure, adhering to the third normal form (3NF). Previously, any update to a project involved downloading the entire project tree, making changes, and uploading a new project under a new ID to ensure complete auditability.</p>
<p>This approach is inefficient for small updates and doesn't allow for granular tracking of changes. The goal is to enable small, precise updates to projects while maintaining a comprehensive audit trail of all changes.</p>
<h2 id="solution-overview">Solution Overview</h2>
<p>We introduce an audit table that records every change made to the database. The audit table will store serialized JSON representations of operations like <code>update</code>, <code>insert</code>, and <code>delete</code>. We'll also provide C# code to apply and revert these changes, effectively creating an undo stack.</p>
<p>Let's use the following DB Schema for illustration:</p>
<p><img src="/posts/images/audit-trail/TableStructureBlog.png" class="img-fluid" alt="TableVide" /></p>
<ul>
<li>Primary Keys: Each table has a primary key (e.g., <code>ProjectID</code>, <code>InstrumentID</code>).</li>
<li>Foreign Keys: Child tables reference their parent via foreign keys (e.g., <code>instruments.ProjectID</code> references <code>projects.ProjectID</code>).</li>
<li>Audit Table: The <code>change_audit</code> table records changes with fields like <code>ChangeAuditID</code>, <code>TimeApplied</code>, and <code>ImpactJson</code>.</li>
</ul>
<!-- 
```d2
projects: {
  shape: sql_table
  ProjectID: int {constraint: primary_key}
  Name: varchar(100)
  Description: text
  LastUpdated: timestamp with time zone
  VersionNumber: int
}

instruments: {
  shape: sql_table
  InstrumentID: int {constraint: primary_key}
  ProjectID: int {constraint: foreign_key}
  Name: varchar(100)
  Type: varchar(50)
  LastUpdated: timestamp with time zone
}

markets: {
  shape: sql_table
  MarketID: int {constraint: primary_key}
  ProjectID: int {constraint: foreign_key}
  Region: varchar(50)
  MarketType: varchar(50)
  LastUpdated: timestamp with time zone
}

valuations: {
  shape: sql_table
  ValuationID: int {constraint: primary_key}
  ProjectID: int {constraint: foreign_key}
  Value: decimal(10, 2)
  Currency: varchar(10)
  LastUpdated: timestamp with time zone
}

change_audit: {
  shape: sql_table
  ChangeAuditID: int {constraint: primary_key}
  TimeApplied: timestamp with time zone
  UserID: varchar(100)
  ImpactJson: jsonb
}

instruments.ProjectID -> projects.ProjectID
markets.ProjectID -> projects.ProjectID
valuations.ProjectID -> projects.ProjectID

```
-->
<h2 id="implementing-change-auditing">Implementing Change Auditing</h2>
<p>The <code>change_audit</code> table is designed to store all changes in a JSON format for flexibility and ease of storage.</p>
<pre><code class="language-sql">CREATE TABLE change_audit (
  ChangeAuditID   NUMBER PRIMARY KEY,
  TimeApplied     TIMESTAMP,
  UserID          VARCHAR2(100),
  ImpactJson      CLOB
);
</code></pre>
<h2 id="json-structure-for-changes">JSON Structure for Changes</h2>
<p>Each change is recorded as a JSON object:</p>
<pre><code class="language-json">{
  &quot;Operation&quot;: &quot;update&quot;,
  &quot;impact&quot;: [
    {
      &quot;Table&quot;: &quot;Instruments&quot;,
      &quot;PrimaryKey&quot;: {&quot;ProjectID&quot;: 4, &quot;InstrumentID&quot;: 2},
      &quot;Column&quot;: &quot;Name&quot;,
      &quot;OldValue&quot;: &quot;Old Instrument Name&quot;,
      &quot;NewValue&quot;: &quot;Updated Instrument Name&quot;
    }
  ]
}
</code></pre>
<h2 id="csharp-to-apply-changes-given-an-operation">CSharp to apply changes given an operation</h2>
<p>To apply changes recorded in the JSON, we'll use C# code that parses the JSON and executes the corresponding SQL commands.</p>
<p>I assume you have the <code>_connectionString</code> available somewhere as a constant in the code.</p>
<pre><code class="language-csharp">using Oracle.ManagedDataAccess.Client;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;

public class ChangeApplier
{

    public void ApplyChanges(string jsonInput)
    {
        // Parse the JSON input
        var operation = JObject.Parse(jsonInput);
        string opType = operation[&quot;Operation&quot;].ToString();
        var impactList = (JArray)operation[&quot;impact&quot;];

        using (var conn = new OracleConnection(_connectionString))
        {
            conn.Open();
            using (var transaction = conn.BeginTransaction())
            {
                try
                {
                    foreach (var impact in impactList)
                    {
                        string table = impact[&quot;Table&quot;].ToString();
                        var primaryKey = (JObject)impact[&quot;PrimaryKey&quot;];
                        string column = impact[&quot;Column&quot;]?.ToString();
                        string newValue = impact[&quot;NewValue&quot;]?.ToString();

                        switch (opType)
                        {
                            case &quot;update&quot;:
                                ApplyUpdate(conn, table, primaryKey, column, newValue);
                                break;
                            case &quot;insert&quot;:
                                ApplyInsert(conn, table, impact);
                                break;
                            case &quot;delete&quot;:
                                ApplyDelete(conn, table, primaryKey);
                                break;
                        }
                    }

                    transaction.Commit();
                }
                catch (Exception ex)
                {
                    transaction.Rollback();
                    Console.WriteLine($&quot;Error applying changes: {ex.Message}&quot;);
                }
            }
        }
    }

    private void ApplyUpdate(OracleConnection conn, string table, JObject primaryKey, string column, string newValue)
    {
        var pkConditions = BuildPrimaryKeyCondition(primaryKey);
        var query = $&quot;UPDATE {table} SET {column} = :newValue WHERE {pkConditions}&quot;;

        using (var cmd = new OracleCommand(query, conn))
        {
            cmd.Parameters.Add(new OracleParameter(&quot;newValue&quot;, newValue));
            cmd.ExecuteNonQuery();
        }
    }

    private void ApplyInsert(OracleConnection conn, string table, JToken impact)
    {
        var primaryKey = (JObject)impact[&quot;PrimaryKey&quot;];
        var newValues = (JObject)impact[&quot;NewValues&quot;];
        var columns = new List&lt;string&gt;();
        var values = new List&lt;string&gt;();

        foreach (var property in primaryKey.Properties())
        {
            columns.Add(property.Name);
            values.Add($&quot;:{property.Name}&quot;);
        }

        foreach (var property in newValues.Properties())
        {
            columns.Add(property.Name);
            values.Add($&quot;:{property.Name}&quot;);
        }

        var query = $&quot;INSERT INTO {table} ({string.Join(&quot;, &quot;, columns)}) VALUES ({string.Join(&quot;, &quot;, values)})&quot;;

        using (var cmd = new OracleCommand(query, conn))
        {
            foreach (var property in primaryKey.Properties())
            {
                cmd.Parameters.Add(new OracleParameter(property.Name, property.Value.ToString()));
            }

            foreach (var property in newValues.Properties())
            {
                cmd.Parameters.Add(new OracleParameter(property.Name, property.Value.ToString()));
            }

            cmd.ExecuteNonQuery();
        }
    }

    private void ApplyDelete(OracleConnection conn, string table, JObject primaryKey)
    {
        var pkConditions = BuildPrimaryKeyCondition(primaryKey);
        var query = $&quot;DELETE FROM {table} WHERE {pkConditions}&quot;;

        using (var cmd = new OracleCommand(query, conn))
        {
            cmd.ExecuteNonQuery();
        }
    }

    private string BuildPrimaryKeyCondition(JObject primaryKey)
    {
        var conditions = new List&lt;string&gt;();
        foreach (var prop in primaryKey.Properties())
        {
            conditions.Add($&quot;{prop.Name} = :{prop.Name}&quot;);
        }
        return string.Join(&quot; AND &quot;, conditions);
    }
}
</code></pre>
<ul>
<li><strong>ApplyChanges</strong>: Parses the JSON input and determines the operation type.</li>
<li><strong>ApplyUpdate</strong>: Executes an UPDATE SQL command using parameters to prevent SQL injection.</li>
<li><strong>ApplyInsert</strong>: Executes an INSERT SQL command, constructing columns and values from the JSON.</li>
<li><strong>ApplyDelete</strong>: Executes a DELETE SQL command based on the primary key.
BuildPrimaryKeyCondition: Constructs the WHERE clause for SQL commands.</li>
</ul>
<p>A side note, for the insert, you'll have the challenge if you are using auto-incremented IDs, this will mean you don't know the new IDs until you have inserted the data, so you should make sure to capture the new IDs and then create the audit log. This is left as a simple exercise to the reader in case it is necessary.</p>
<h2 id="csharp-to-revert-changes">CSharp to revert changes</h2>
<p>To revert changes (undo operations), we'll process the audit trail in reverse order. Here I give the processing of a list of operations as an example of unrolling. It is to note that the reverse delete does only one table, so if there was some connected information that was deleted via referential identity, it was the task of the audit table to keep that in the audit.</p>
<pre><code class="language-csharp">public class ChangeReverter
{
    public void RevertChanges(List&lt;string&gt; jsonOperations)
    {
        using (var conn = new OracleConnection(_connectionString))
        {
            conn.Open();
            using (var transaction = conn.BeginTransaction())
            {
                try
                {
                    jsonOperations.Reverse(); // note: you could also have provided sorted by last time from the audit table instead of reversing them

                    foreach (var operationJson in jsonOperations)
                    {
                        var operation = JObject.Parse(operationJson);
                        string opType = operation[&quot;Operation&quot;].ToString();
                        var impactList = (JArray)operation[&quot;impact&quot;];

                        foreach (var impact in impactList)
                        {
                            string table = impact[&quot;Table&quot;].ToString();
                            var primaryKey = (JObject)impact[&quot;PrimaryKey&quot;];
                            string column = impact[&quot;Column&quot;]?.ToString();
                            string oldValue = impact[&quot;OldValue&quot;]?.ToString();

                            switch (opType)
                            {
                                case &quot;update&quot;:
                                    RevertUpdate(conn, table, primaryKey, column, oldValue);
                                    break;
                                case &quot;insert&quot;:
                                    ApplyDelete(conn, table, primaryKey);
                                    break;
                                case &quot;delete&quot;:
                                    RevertDelete(conn, table, impact);
                                    break;
                            }
                        }
                    }

                    transaction.Commit();
                }
                catch (Exception ex)
                {
                    transaction.Rollback();
                    Console.WriteLine($&quot;Error reverting changes: {ex.Message}&quot;);
                }
            }
        }
    }

    private void RevertUpdate(OracleConnection conn, string table, JObject primaryKey, string column, string oldValue)
    {
        var pkConditions = BuildPrimaryKeyCondition(primaryKey);
        var query = $&quot;UPDATE {table} SET {column} = :oldValue WHERE {pkConditions}&quot;;

        using (var cmd = new OracleCommand(query, conn))
        {
            cmd.Parameters.Add(new OracleParameter(&quot;oldValue&quot;, oldValue));
            cmd.ExecuteNonQuery();
        }
    }

    private void RevertDelete(OracleConnection conn, string table, JToken impact)
    {
        var primaryKey = (JObject)impact[&quot;PrimaryKey&quot;];
        var oldValues = (JObject)impact[&quot;OldValues&quot;];
        var columns = new List&lt;string&gt;();
        var values = new List&lt;string&gt;();

        foreach (var property in primaryKey.Properties())
        {
            columns.Add(property.Name);
            values.Add($&quot;:{property.Name}&quot;);
        }

        foreach (var property in oldValues.Properties())
        {
            columns.Add(property.Name);
            values.Add($&quot;:{property.Name}&quot;);
        }

        var query = $&quot;INSERT INTO {table} ({string.Join(&quot;, &quot;, columns)}) VALUES ({string.Join(&quot;, &quot;, values)})&quot;;

        using (var cmd = new OracleCommand(query, conn))
        {
            foreach (var property in primaryKey.Properties())
            {
                cmd.Parameters.Add(new OracleParameter(property.Name, property.Value.ToString()));
            }

            foreach (var property in oldValues.Properties())
            {
                cmd.Parameters.Add(new OracleParameter(property.Name, property.Value.ToString()));
            }

            cmd.ExecuteNonQuery();
        }
    }

    // Reuse BuildPrimaryKeyCondition and ApplyDelete methods from ChangeApplier
}
</code></pre>
<ul>
<li><strong>RevertChanges</strong>: Processes the list of JSON operations in reverse order to undo changes.</li>
<li><strong>RevertUpdate</strong>: Sets the column back to its old value.</li>
<li><strong>RevertDelete</strong>: Re-inserts a deleted row using the old values stored in the audit trail.</li>
<li><strong>ApplyDelete</strong>: Deletes a row, used here to undo an insert operation.</li>
</ul>
<h2 id="json-schema">JSON schema</h2>
<p>The reason that I prefer to use the Json directly in the C# code is that actually making up the C# classes for this schema is actually more work that processing the json directly in the code.</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;title&quot;: &quot;ImpactJsonRoot&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;Operation&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;enum&quot;: [&quot;update&quot;, &quot;insert&quot;, &quot;delete&quot;],
      &quot;description&quot;: &quot;Type of operation&quot;
    },
    &quot;Impact&quot;: {
      &quot;type&quot;: &quot;array&quot;,
      &quot;items&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
          &quot;Table&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Name of the table affected&quot;
          },
          &quot;PrimaryKey&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;description&quot;: &quot;Primary key fields and their values&quot;,
            &quot;additionalProperties&quot;: {
              &quot;type&quot;: [&quot;number&quot;, &quot;null&quot;]
            }
          },
          &quot;Column&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Column affected (for updates)&quot;
          },
          &quot;OldValue&quot;: {
            &quot;type&quot;: [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;null&quot;],
            &quot;description&quot;: &quot;Previous value (for updates and deletes)&quot;
          },
          &quot;NewValue&quot;: {
            &quot;type&quot;: [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;null&quot;],
            &quot;description&quot;: &quot;New value (for updates and inserts)&quot;
          },
          &quot;OldValues&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;description&quot;: &quot;All old values (for deletes)&quot;,
            &quot;additionalProperties&quot;: {
              &quot;type&quot;: [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;null&quot;]
            }
          },
          &quot;NewValues&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;description&quot;: &quot;All new values (for inserts)&quot;,
            &quot;additionalProperties&quot;: {
              &quot;type&quot;: [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;null&quot;]
            }
          }
        },
        &quot;required&quot;: [&quot;Table&quot;, &quot;PrimaryKey&quot;]
      }
    }
  },
  &quot;required&quot;: [&quot;Operation&quot;, &quot;Impact&quot;]
}
</code></pre>
<p>and here are examples of operations:</p>
<h3 id="update">update</h3>
<pre><code class="language-json">{
  &quot;Operation&quot;: &quot;update&quot;,
  &quot;Impact&quot;: [
    {
      &quot;Table&quot;: &quot;Instruments&quot;,
      &quot;PrimaryKey&quot;: { &quot;ProjectID&quot;: 4, &quot;InstrumentID&quot;: 2 },
      &quot;Column&quot;: &quot;Name&quot;,
      &quot;OldValue&quot;: &quot;Old Instrument Name&quot;,
      &quot;NewValue&quot;: &quot;Updated Instrument Name&quot;
    }
  ]
}

</code></pre>
<h3 id="insert">insert</h3>
<pre><code class="language-json">{
  &quot;Operation&quot;: &quot;insert&quot;,
  &quot;Impact&quot;: [
    {
      &quot;Table&quot;: &quot;Instruments&quot;,
      &quot;PrimaryKey&quot;: { &quot;ProjectID&quot;: 4, &quot;InstrumentID&quot;: 10 },
      &quot;NewValues&quot;: {
        &quot;Name&quot;: &quot;New Instrument&quot;,
        &quot;Type&quot;: &quot;Flexible Asset&quot;,
        &quot;LastUpdated&quot;: &quot;2024-10-05T12:34:56Z&quot;
      }
    }
  ]
}
</code></pre>
<h3 id="delete">delete</h3>
<pre><code class="language-json">{
  &quot;Operation&quot;: &quot;delete&quot;,
  &quot;Impact&quot;: [
    {
      &quot;Table&quot;: &quot;Instruments&quot;,
      &quot;PrimaryKey&quot;: { &quot;ProjectID&quot;: 4, &quot;InstrumentID&quot;: 5 },
      &quot;OldValues&quot;: {
        &quot;Name&quot;: &quot;Obsolete Instrument&quot;,
        &quot;Type&quot;: &quot;Flexible Asset&quot;,
        &quot;LastUpdated&quot;: &quot;2024-10-01T09:15:00Z&quot;
      }
    }
  ]
}
</code></pre>
<p>Note: OpenAI's <code>o1-preview</code> was used to assist in the creation of the post.</p>


<hr>
					</div>
				</div>
			</div>

			<!-- Footer -->
			<footer id="footer">
				<div class="inner">
    <section>
        <h2>Feeds</h2>
        <ul class="actions small vertical">
            <li><a href="/feed.rss" class="button small"><i class="fa fa-rss"></i> RSS Feed</a></li>
                        <li><a href="/feed.atom" class="button small"><i class="fa fa-rss"></i> Atom Feed</a></li>
        </ul>
    </section>
    <section>
    </section>
    <ul class="copyright">
        <li>Copyright © 2024</li>
        <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
        <li><a href="https://wyam.io">Generated by Wyam</a></li>
    </ul>
</div>

			</footer>

		</div>
		
		

		<!-- Scripts -->
		<script>hljs.initHighlightingOnLoad();</script>
		<script src="/assets/js/jquery.min.js"></script>
		<script src="/assets/js/skel.min.js"></script>
		<script src="/assets/js/util.js"></script>
		<!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
		<script src="/assets/js/main.js"></script>

	</body>

</html>
