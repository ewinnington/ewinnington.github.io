
<!DOCTYPE html>
<!--
	Phantom by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en">

	<head>
		<title>Eric Winnington - It&#x2019;s a proportional allocation - how hard can it be? Going from Water filling to QP</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1" />		
        <link href="/assets/css/highlight.css" rel="stylesheet">
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
        <link href="/assets/css/override.css" rel="stylesheet" />

		<meta name="description" content="A collection of thoughts, code and snippets." />
		<link type="application/rss+xml" rel="alternate" title="Eric Winnington" href="/feed.rss" />
				<link type="application/atom+xml" rel="alternate" title="Eric Winnington" href="/feed.atom" />
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<link rel="icon" href="/favicon.ico" type="image/x-icon">

		<meta name="application-name" content="Eric Winnington" />
		<meta name="msapplication-tooltip" content="Eric Winnington" />
		<meta name="msapplication-starturl" content="/" />

		<meta property="og:title" content="Eric Winnington - It&#x2019;s a proportional allocation - how hard can it be? Going from Water filling to QP" /> 
		<meta property="og:type" content="website" />
		<meta property="og:url" content="http://ewinnington.github.io/posts/MIQP" />
		<!-- TODO: More social graph meta tags -->

        <script src="/assets/js/highlight.pack.js"></script>   
		
        <meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@ewinnington" />
<meta name="twitter:title" content="Eric Winnington - It&#x2019;s a proportional allocation - how hard can it be? Going from Water filling to QP" />
<meta name="twitter:description" content="A collection of thoughts, code and snippets." />

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
		
	</head>

	<body>
		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
			<header id="header">
				<div class="inner">

					<!-- Logo -->
					<a href="/" class="logo">
						<span class="title">Eric Winnington</span>
					</a>

					<!-- Nav -->
					<nav>
						<ul>
							<li><a href="#menu">Menu</a></li>
						</ul>
					</nav>

				</div>
			</header>

			<!-- Menu -->
			<nav id="menu">
				<h2>Menu</h2>
				<ul>
					        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/about">About Me</a></li>
        <li><a href="/videos">Videos on programming</a></li>

				</ul>
			</nav>

			<!-- Main -->
			<div id="main">
				<div class="inner">

    
<header>
    <h1>It&#x2019;s a proportional allocation - how hard can it be? Going from Water filling to QP</h1>
            <p><em>Published on Wednesday, 16 April 2025</em></p>
            <ul class="actions small">
                    <li><a role="button" href="/tags/LinearProgramming" class="button small">LinearProgramming</a></li>
                    <li><a role="button" href="/tags/MILP" class="button small">MILP</a></li>
                    <li><a role="button" href="/tags/MIQP" class="button small">MIQP</a></li>
        </ul>     
</header>

					
					<div id="content">
						

<h1 id="its-a-proportional-allocation-how-hard-can-it-be-miqp">It’s a proportional allocation - how hard can it be? MIQP</h1>
<p>Alice, Bob and Charlie buy a pizza and they each put down a part of the price, respectively 50%, 30% and 20%. Pizza arrives and they slice it up and eat it. But Alice gets full after eating 40% of her 50% slice, how do we allocate the remaining 10% slice to Bob and Charlie? Her 10% can be cut up into 2% slices and we proportionally give 3 to Bob (total 36%) and 2 to Charlie (total 24%).</p>
<p>We have a total allocation of 100 MW of power to allocate to three products, in the ideal allocation with (0.5, 0.3, 0.2) ratio and each product has a maximum of 40MW.</p>
<p>These two problems are the same.</p>
<h2 id="waterfilling-algorithm">Waterfilling algorithm</h2>
<p>There exists a well known algorithm for solving this problem, the water filling algorithm.</p>
<p>In essence, we are looking at finding the level of water across three containers that is flat along the allocation amount.</p>
<h3 id="definitions">definitions:</h3>
<ul>
<li><span class="math">\(w_i\)</span> is the weight from product i</li>
<li><span class="math">\(w'_i\)</span> is the updated weight when we have fewer products due to saturation</li>
<li><span class="math">\(M_i\)</span> is the maximum of product i</li>
<li><span class="math">\(x'_i\)</span> is the initial / ideal allocation in case the products are not saturated</li>
<li><span class="math">\(x_i\)</span> is the current allocation to the product</li>
<li><span class="math">\(T\)</span> is total allocation amount to spread over the products</li>
<li><span class="math">\(T_r\)</span> is the remaining allocation to spread over products after the saturated products are removed from T</li>
<li><span class="math">\(saturated\)</span> : means that the allocation is &gt;= max on the product.</li>
<li><span class="math">\(unsaturated\)</span> : means that the allocation is &lt; max on the product</li>
</ul>
<h3 id="water-filling-iterative-algorithm">Water-Filling (Iterative) Algorithm:</h3>
<ul>
<li>Step 1: Compute the ideal allocations <span class="math">\(x'_i = w_i \cdot T\)</span></li>
<li>Step 2: For any product i for which <span class="math">\(x'_i &gt;= M_i\)</span> (saturated), set <span class="math">\(x_i =M_i\)</span>, otherwise <span class="math">\(x_i = x'_i\)</span>.</li>
<li>Step 3: Compute the remaining capacity by removing the capacity of saturated <span class="math">\(x_i\)</span> : <span class="math">\(T_r = T − \sum_{i_{\text{saturated}}} M_i\)</span>.</li>
<li>Step 4: For the remaining (unsaturated) products, redistribute <span class="math">\(T_r\)</span> proportionally based on their weights normalized over the unsaturated set <span class="math">\(x_i = w^{\prime}_i \cdot T_r\)</span> where <span class="math">\(w^{\prime}_i = \frac{w_i}{\sum_j w_j}\)</span> with <span class="math">\(j\)</span> representing the unsaturated products</li>
<li>Step 5: Repeat the process if additional products get saturated during the redistribution, ie. from Step 2.</li>
</ul>
<p>The reason this terminates is that because we remove saturated products from the list, the next products get allocated and the set gets reduced, either a new product is saturated and the cycle continues or the final allocation is done and terminates.</p>
<pre><code class="language-python">import numpy as np

def iterative_waterfilling(T, weights, max_allocations):
    n = len(weights)
    allocations = np.zeros(n)
    unsaturated = np.array([True] * n)
    remaining_T = T

    while True:
        # Calculate proportional weights for unsaturated products
        current_weights = np.array(weights) * unsaturated
        total_current_weight = np.sum(current_weights)
        
        # Calculate ideal allocation for unsaturated products
        ideal_allocations = (current_weights / total_current_weight) * remaining_T

        # Check for saturation
        newly_saturated = ideal_allocations &gt;= max_allocations
        
        # Update allocations and saturation status
        if not np.any(newly_saturated &amp; unsaturated):
            allocations[unsaturated] = ideal_allocations[unsaturated]
            break
        
        for i in range(n):
            if unsaturated[i] and newly_saturated[i]:
                allocations[i] = max_allocations[i]
                unsaturated[i] = False
                remaining_T -= allocations[i]

    return allocations

T = 100
weights = [0.5, 0.3, 0.2]
max_allocations = [40, 40, 40]

allocations_result = iterative_waterfilling(T, weights, max_allocations)
print(&quot;Iterative Waterfilling Result:&quot;, allocations_result)
</code></pre>
<h3 id="examples">Examples</h3>
<p>Example 1 - total 100, allocation (0.5,0.3,0.2), maximum (40,40,40), result (40,36,24)</p>
<p>Example 2 - total 100, allocation (0.5,0.3,0.2), maximum (40,34,40), result (40,34,26)</p>
<p>The problem of this algorithm is that while it works wonderfully for simple proportional problems, as soon as you start adding more constraints (minimums) and relations between the allocations, this iterative algorithm doesn’t work that great.</p>
<p>So how do we solve this as an optimization problem? We want to find a solution that when unconstrained (unsaturated) falls back to the proportional allocation and when constrained (saturated maximum) falls back to the waterfilling algorithm.</p>
<h2 id="from-waterfilling-to-qp-mixed-integer-quadratic-programming">From Waterfilling to QP : Mixed integer quadratic programming</h2>
<p>While the iterative waterfilling algorithm effectively solves basic proportional allocation problems, it struggles under more complex scenarios involving additional constraints, such as minimum allocation limits or relational constraints between allocations. To robustly handle these real-world complexities, we leverage Mixed Integer Quadratic Programming (MIQP). MIQP elegantly generalizes the waterfilling logic into an optimization framework, allowing precise specification of constraints and objectives. By translating allocation decisions into a mathematical optimization problem, we ensure optimal, constraint-respecting allocations, making it suitable for applications demanding reliability and flexibility.</p>
<h3 id="definitions-1">Definitions:</h3>
<ul>
<li><span class="math">\(T\)</span>: total</li>
<li><span class="math">\(w_i\)</span>: weight</li>
<li><span class="math">\(M_i\)</span>: Maximum of allocation</li>
<li><span class="math">\(d_i\)</span>: product saturated marker ($\in \mathbb, binary \in \lbrace 0,1 \rbrace $), 0 unsaturated, 1 saturated</li>
<li><span class="math">\(x_i\)</span>: allocation amount</li>
<li><span class="math">\(v_i\)</span>: target water level for unsaturated product (shared identity)</li>
<li><span class="math">\(U\)</span>: upper large bound</li>
</ul>
<h3 id="objective">Objective:</h3>
<p><span class="math">\(\min \sum_i (x_i - w_i T)^2\)</span></p>
<h3 id="constraints">Constraints:</h3>
<h4 id="i-basic-allocation-limits">(I) Basic allocation limits</h4>
<p><span class="math">\(\forall i \quad x_i \geq 0 \quad (a)\)</span></p>
<p><span class="math">\(\forall i \quad x_i \leq M_i \quad (b)\)</span></p>
<h4 id="ii-total-allocation-constraint">(II) Total allocation constraint</h4>
<p><span class="math">\(\sum_i x_i \leq T\)</span></p>
<h4 id="iii-saturation-constraints">(III) Saturation constraints <span class="math">\(\forall i\)</span></h4>
<p><span class="math">\(x_i = w_i \cdot v_i + M_i \cdot d_i \quad (a)\)</span></p>
<p><span class="math">\(v_i \leq U \cdot (1 - d_i) \quad (b) \quad \text{with } v_i = 0 \text{ when saturated}\)</span></p>
<p><span class="math">\(v_i \geq 0 \quad (c)\)</span></p>
<p><span class="math">\(v_i \leq \frac{M_i}{w_i} \cdot (1 - d_i) + U \cdot d_i \quad (d)\)</span></p>
<h4 id="iv-water-level-equality-constraints-across-unsaturated-products">(IV) Water level equality constraints across unsaturated products</h4>
<p><span class="math">\(\forall i (1 \rightarrow n), \quad \forall j (i+1 \rightarrow n)\)</span></p>
<p><span class="math">\(v_i - v_j \leq U \cdot (d_i + d_j)\)</span></p>
<p><span class="math">\(v_j - v_i \leq U \cdot (d_i + d_j)\)</span></p>
<p><em>If both are unsaturated, it means <span class="math">\(d_i = d_j = 0\)</span>, thus forcing <span class="math">\(v_i = v_j\)</span>.</em></p>
<h3 id="explanation-of">Explanation of <span class="math">\(v_i\)</span></h3>
<p>This set of equations sets up <span class="math">\(v_i\)</span> as a shared value <span class="math">\(z\)</span> across all unsaturated products.</p>
<p>$$40 + (w_1 + w_2) \cdot z = 100$$</p>
<p><span class="math">\((0.3 + 0.2) z = 60\)</span></p>
<p><span class="math">\(z = 120\)</span></p>
<p><span class="math">\(x_1 = 0.3 \cdot 120 = 36\)</span></p>
<p><span class="math">\(x_2 = 0.2 \cdot 120 = 24\)</span></p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<pre><code class="language-python">#pip install numpy
#pip install cvxpy
#pip install ecos

import cvxpy as cp
import numpy as np

# Problem parameters
T = 100.0
w = [0.5, 0.3, 0.2]          # target weights for products 1, 2, and 3
M_max = [40.0, 40.0, 40.0]     # maximum allocation for each product

# Number of products
n = len(w)

# A sufficiently large constant U (big-M) for enforcing water-level equality.
U = 500.0

# Decision variables:
# x: allocation amounts
x = cp.Variable(n)
# v: auxiliary &quot;water-level&quot; variables for unsaturated products
v = cp.Variable(n)
# delta: binary variables; delta[i] = 1 means product i is saturated (x[i] = M_max[i])
delta = cp.Variable(n, boolean=True)

constraints = []

# For each product, define the allocation as the sum of the unsaturated part and the saturation term.
for i in range(n):
    # If not saturated (delta[i] = 0) then x[i] = w[i]*v[i].
    # If saturated (delta[i] = 1) then x[i] = M_max[i].
    constraints.append(x[i] == w[i] * v[i] + M_max[i] * delta[i])
    
    # Force v[i] = 0 when saturated, by bounding v[i] to 0 when delta[i]=1.
    constraints.append(v[i] &lt;= U * (1 - delta[i]))
    # Ensure nonnegativity of v.
    constraints.append(v[i] &gt;= 0)
    # When unsaturated (delta[i]=0), we must have x[i] = w[i]*v[i] ≤ M_max[i]. 
    # Throught: Why not T here instead of M_max[i]? -&gt; it would be correct, but M_max[i] is a more restrictive boundary so helps convergence
    constraints.append(v[i] &lt;= (M_max[i] / w[i]) * (1 - delta[i]) + U * delta[i])

# Enforce that all unsaturated products share the same water-level.
# For every pair (i,j), if both are unsaturated (delta[i] = delta[j] = 0) then v[i] must equal v[j].
for i in range(n):
    for j in range(i+1, n):
        constraints.append(v[i] - v[j] &lt;= U * (delta[i] + delta[j]))
        constraints.append(v[j] - v[i] &lt;= U * (delta[i] + delta[j]))

# Total allocation constraint: the sum of all allocations must equal the available capacity.
constraints.append(cp.sum(x) == T)

# Ensure each x[i] does not exceed its maximum. (These could be built in via the definition of x.)
for i in range(n):
    constraints.append(x[i] &gt;= 0)
    constraints.append(x[i] &lt;= M_max[i])

# Define the target allocation for each product (unconstrained ideals)
target = np.array([w_i * T for w_i in w])

# Objective: minimize squared deviation from the ideal allocation.
objective = cp.Minimize(cp.sum_squares(x - target))

# Define and solve the MIQP.
# Use a MIQP-capable solver such as GUROBI, CPLEX, ECOS_BB, etc.
prob = cp.Problem(objective, constraints)
result = prob.solve(solver=cp.ECOS_BB)


print(&quot;Status:&quot;, prob.status)
print(&quot;Optimal value:&quot;, result)
print(&quot;Optimal allocations:&quot;)
for i in range(n):
    print(f&quot;  x[{i+1}] = {x.value[i]:.4f}&quot;)
print(&quot;Water-level (v) values:&quot;)
for i in range(n):
    print(f&quot;  v[{i+1}] = {v.value[i]:.4f}&quot;)
print(&quot;Saturation indicators (delta) values:&quot;)
for i in range(n):
    print(f&quot;  delta[{i+1}] = {delta.value[i]:.4f}&quot;)

# Expected behavior for this example:
# - For product 1, the unconstrained target is 50 but M_max[0]=40, so we expect it to be saturated (delta[0]=1, x[0]=40).
# - For products 2 and 3 (unsaturated, delta = 0), they share the same water-level z.
#   The total allocation constraint becomes: 40 + (w[1] + w[2]) * z = 100  --&gt;  (0.3+0.2)*z = 60, so z = 120.
#   Hence, x[2] = 0.3 * 120 = 36 and x[3] = 0.2 * 120 = 24.
</code></pre>
<h2 id="summary">Summary</h2>
<p>In business applications, we often see allocations that should be &quot;preference based&quot; if unconstrained, but then with different constraints it becomes complicated to tease out the preferences in an optimal way. This QP application shows a way to have an allocation identical to the water filling, but with the flexibility of QP.</p>
<p>If you were simplifying the QP constraints to remove the equations (IV), the output would be (40, 35, 25) since that minimises the objective function.</p>
<p>This example here is taken out of an abstration of a practical problem of allocating ancillary service capacity to a series of contracts, with trader preferences. This chapter is part of my book &quot;Energy - From Asset to Cashflow&quot; (not yet published).</p>


<hr>
					</div>
				</div>
			</div>

			<!-- Footer -->
			<footer id="footer">
				<div class="inner">
    <section>
        <h2>Feeds</h2>
        <ul class="actions small vertical">
            <li><a href="/feed.rss" class="button small"><i class="fa fa-rss"></i> RSS Feed</a></li>
                        <li><a href="/feed.atom" class="button small"><i class="fa fa-rss"></i> Atom Feed</a></li>
        </ul>
    </section>
    <section>
    </section>
    <ul class="copyright">
        <li>Copyright © 2025</li>
        <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
        <li><a href="https://wyam.io">Generated by Wyam</a></li>
    </ul>
</div>

			</footer>

		</div>
		
		

		<!-- Scripts -->
		<script>hljs.initHighlightingOnLoad();</script>
		<script src="/assets/js/jquery.min.js"></script>
		<script src="/assets/js/skel.min.js"></script>
		<script src="/assets/js/util.js"></script>
		<!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
		<script src="/assets/js/main.js"></script>

	</body>

</html>
